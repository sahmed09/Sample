// ============================================================================
// Combined Anti-Ransomware DLL
// Techniques included (logic UNCHANGED; original comments preserved):
//   [A] File Based Encryption (CreateFileA / WriteFile / SetFilePointer / FlushFileBuffers / CloseHandle)
//   [B] File Renaming & Extension Changes (MoveFileW / MoveFileExW)
// -----------------------------------------------------------------------------
// Notes:
//  - Only minimal adjustments to live in one file: shared includes/pragma and a
//    unified NativeInjectionEntryPoint that installs BOTH sets of hooks.
//  - All hook function bodies and helper logic remain identical to your originals.
// ============================================================================

#include "pch.h"
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <easyhook.h>

#ifdef _WIN64
#pragma comment(lib, "EasyHook64.lib") // or EasyHook32.lib as appropriate
#else
#pragma comment(lib, "EasyHook32.lib") // or EasyHook64.lib as appropriate
#endif

using namespace std;


// ============================================================================
// [A] DLL Code of File Based Encryption (ORIGINAL CONTENT PRESERVED)
// ============================================================================


// ---- CONFIG ----
const std::wstring TARGET_DIR = L"C:\\Users\\User\\Documents\\MalwareAnalysis\\ClipboardLogger\\Debug\\Files";
const std::vector<std::wstring> TARGET_EXTENSIONS = { L".docx", L".xlsx", L".db", L".txt" };

// ---- HELPERS ----
std::wstring ToLower(const std::wstring& str) {
	std::wstring s = str;
	std::transform(s.begin(), s.end(), s.begin(), ::towlower);
	return s;
}

bool EndsWith(const std::wstring& str, const std::wstring& suffix) {
	if (suffix.size() > str.size()) return false;
	return std::equal(suffix.rbegin(), suffix.rend(), str.rbegin());
}

bool IsTargetFile(const std::wstring& path) {
	std::wstring lowpath = ToLower(path);
	// Check if file is in the target directory
	if (lowpath.find(ToLower(TARGET_DIR)) != 0)
		return false;
	// Check for matching extension
	for (auto& ext : TARGET_EXTENSIONS)
		if (EndsWith(lowpath, ext))
			return true;
	return false;
}

// ---- Original API pointers ----
decltype(&CreateFileA) TrueCreateFileA = CreateFileA;
decltype(&WriteFile) TrueWriteFile = WriteFile;
decltype(&SetFilePointer) TrueSetFilePointer = SetFilePointer;
decltype(&FlushFileBuffers) TrueFlushFileBuffers = FlushFileBuffers;

// ---- Tracking handles of protected files ----
std::vector<HANDLE> g_protectedHandles;

// ---- HOOKED APIS ----

// CreateFileA Hook
HANDLE WINAPI MyCreateFileA(
	LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode,
	LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition,
	DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
	std::wstring fileNameW;
	int size = MultiByteToWideChar(CP_ACP, 0, lpFileName, -1, NULL, 0);
	if (size > 0) {
		fileNameW.resize(size - 1);
		MultiByteToWideChar(CP_ACP, 0, lpFileName, -1, &fileNameW[0], size);
	}

	HANDLE hFile = TrueCreateFileA(
		lpFileName, dwDesiredAccess, dwShareMode,
		lpSecurityAttributes, dwCreationDisposition,
		dwFlagsAndAttributes, hTemplateFile);

	if (IsTargetFile(fileNameW)) {
		std::wcout << L"[Ransomware DEFENSE] Protected file opened: " << fileNameW << std::endl;
		if (hFile != INVALID_HANDLE_VALUE)
			g_protectedHandles.push_back(hFile);
	}
	return hFile;
}

// WriteFile Hook
BOOL WINAPI MyWriteFile(
	HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite,
	LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
{
	// Check if this handle is protected
	if (std::find(g_protectedHandles.begin(), g_protectedHandles.end(), hFile) != g_protectedHandles.end()) {
		if (lpNumberOfBytesWritten)*lpNumberOfBytesWritten = nNumberOfBytesToWrite;
		std::cout << "[Ransomware DEFENSE] WriteFile FAKE success (blocked ransomware attempt)." << std::endl;
		return TRUE; // Fake success: block real writes!
	}
	return TrueWriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
}

// SetFilePointer Hook
DWORD WINAPI MySetFilePointer(
	HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
{
	if (std::find(g_protectedHandles.begin(), g_protectedHandles.end(), hFile) != g_protectedHandles.end()) {
		std::cout << "[Ransomware DEFENSE] SetFilePointer FAKE success (blocked ransomware attempt)." << std::endl;
		// Return arbitrary valid position (e.g., 0)
		return 0;
	}
	return TrueSetFilePointer(hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);
}

// FlushFileBuffers Hook
BOOL WINAPI MyFlushFileBuffers(HANDLE hFile)
{
	if (std::find(g_protectedHandles.begin(), g_protectedHandles.end(), hFile) != g_protectedHandles.end()) {
		std::cout << "[Ransomware DEFENSE] FlushFileBuffers FAKE success (blocked ransomware attempt)." << std::endl;
		return TRUE; // Fake success
	}
	return TrueFlushFileBuffers(hFile);
}

// Cleanup handles on close (optional)
BOOL WINAPI MyCloseHandle(HANDLE hObject)
{
	auto it = std::find(g_protectedHandles.begin(), g_protectedHandles.end(), hObject);
	if (it != g_protectedHandles.end())
		g_protectedHandles.erase(it);
	return CloseHandle(hObject);
}


// ============================================================================
// [B] DLL Code of File Renaming and Extension Changes (ORIGINAL CONTENT PRESERVED)
// ============================================================================

// Helper: Case-insensitive wstring comparison for extensions
bool EndsWithCaseInsensitive(const std::wstring& s, const std::wstring& suffix) {
	if (s.size() < suffix.size()) return false;
	return _wcsicmp(s.c_str() + (s.size() - suffix.size()), suffix.c_str()) == 0;
}

// Helper: Detect if the new file path has suspicious (ransomware) extensions
bool IsSuspiciousExtension(const std::wstring& newPath) {
	static std::vector<std::wstring> suspicious = {
		L".locked", L".enc", L".encrypted", L".REvil", L".LockBit", L".conti"
	};
	for (const auto& ext : suspicious) {
		if (EndsWithCaseInsensitive(newPath, ext)) return true;
		// Match with possible victim ID as an extra extension
		if (newPath.find(ext + L".") != std::wstring::npos) return true;
	}
	return false;
}

// Hooked MoveFileW
BOOL WINAPI myMoveFileWHook(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName) {
	std::wstring newName(lpNewFileName ? lpNewFileName : L"");
	if (IsSuspiciousExtension(newName)) {
		wcout << L"[RANSOMWARE BLOCKED] MoveFileW: " << lpExistingFileName << L" -> " << lpNewFileName << endl;
		// Return TRUE to fake success (malware thinks it worked, but it didn't)
		return TRUE;
	}
	return MoveFileW(lpExistingFileName, lpNewFileName);
}

// Hooked MoveFileExW
BOOL WINAPI myMoveFileExWHook(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags) {
	std::wstring newName(lpNewFileName ? lpNewFileName : L"");
	if (IsSuspiciousExtension(newName)) {
		wcout << L"[RANSOMWARE BLOCKED] MoveFileExW: " << lpExistingFileName << L" -> " << lpNewFileName << endl;
		// Return TRUE to fake success (malware thinks it worked, but it didn't)
		return TRUE;
	}
	return MoveFileExW(lpExistingFileName, lpNewFileName, dwFlags);
}

// (Optional) Logging to file for forensics
void LogBlockedRename(const std::wstring& oldName, const std::wstring& newName) {
	FILE* logFile;
	_wfopen_s(&logFile, L"c:\\AntiRansomwareLog.txt", L"a+, ccs=UTF-8");
	if (logFile) {
		fwprintf(logFile, L"[BLOCKED] %s -> %s\n", oldName.c_str(), newName.c_str());
		fclose(logFile);
	}
}


// ============================================================================
// Unified EasyHook entry: installs BOTH [A] and [B] hook sets
// (All hook bodies/logic remain exactly as originally written.)
// ============================================================================

extern "C" void __declspec(dllexport) __stdcall NativeInjectionEntryPoint(REMOTE_ENTRY_INFO * inRemoteInfo)
{
	// ---------------------------
	// [A] Install File Based Encryption hooks
	// ---------------------------
	std::cout << "[*] AntiRansomware DLL Injected. Installing hooks..." << std::endl;

	HOOK_TRACE_INFO hCreateFile = { NULL };
	HOOK_TRACE_INFO hWriteFile = { NULL };
	HOOK_TRACE_INFO hSetFilePointer = { NULL };
	HOOK_TRACE_INFO hFlushBuffers = { NULL };
	HOOK_TRACE_INFO hCloseHandle = { NULL };

	LhInstallHook(GetProcAddress(GetModuleHandleA("kernel32.dll"), "CreateFileA"), MyCreateFileA, NULL, &hCreateFile);
	LhInstallHook(GetProcAddress(GetModuleHandleA("kernel32.dll"), "WriteFile"), MyWriteFile, NULL, &hWriteFile);
	LhInstallHook(GetProcAddress(GetModuleHandleA("kernel32.dll"), "SetFilePointer"), MySetFilePointer, NULL, &hSetFilePointer);
	LhInstallHook(GetProcAddress(GetModuleHandleA("kernel32.dll"), "FlushFileBuffers"), MyFlushFileBuffers, NULL, &hFlushBuffers);
	LhInstallHook(GetProcAddress(GetModuleHandleA("kernel32.dll"), "CloseHandle"), MyCloseHandle, NULL, &hCloseHandle);

	// Enable all hooks for all threads in the process
	ULONG ACLEntriesA[1] = { 0 };
	LhSetExclusiveACL(ACLEntriesA, 1, &hCreateFile);
	LhSetExclusiveACL(ACLEntriesA, 1, &hWriteFile);
	LhSetExclusiveACL(ACLEntriesA, 1, &hSetFilePointer);
	LhSetExclusiveACL(ACLEntriesA, 1, &hFlushBuffers);
	LhSetExclusiveACL(ACLEntriesA, 1, &hCloseHandle);

	std::cout << "[*] AntiRansomware hooks installed. Ransomware encryption attempts will be blocked (FAKE success)." << std::endl;

	// ---------------------------
	// [B] Install File Renaming & Extension Changes hooks
	// ---------------------------
	cout << "[*] Anti-Ransomware Rename Hook Injection started." << endl;

	HOOK_TRACE_INFO hMoveFileHook = { NULL };
	HOOK_TRACE_INFO hMoveFileExHook = { NULL };

	// Install MoveFileW hook
	FARPROC moveFileAddr = GetProcAddress(GetModuleHandle(TEXT("kernel32")), "MoveFileW");
	if (LhInstallHook(moveFileAddr, myMoveFileWHook, nullptr, &hMoveFileHook) != 0)
		wcout << L"[!] Failed to hook MoveFileW." << endl;

	// Install MoveFileExW hook
	FARPROC moveFileExAddr = GetProcAddress(GetModuleHandle(TEXT("kernel32")), "MoveFileExW");
	if (LhInstallHook(moveFileExAddr, myMoveFileExWHook, nullptr, &hMoveFileExHook) != 0)
		wcout << L"[!] Failed to hook MoveFileExW." << endl;

	// Enable all hooks for all threads in the process
	ULONG ACLEntriesB[1] = { 0 };
	LhSetExclusiveACL(ACLEntriesB, 1, &hMoveFileHook);
	LhSetExclusiveACL(ACLEntriesB, 1, &hMoveFileExHook);

	wcout << L"[*] Ransomware rename hooks are active.\n";
}
