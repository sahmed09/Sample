// ============================
// Combined Anti-Keylogger DLL
// Source sections preserved verbatim (logic unchanged)
// Techniques included:
//  1) Screen Logging deception via BitBlt (GDI)
//  2) Mouse Tracking deception via GetCursorPos (User32)
//  3) Clipboard Logger deception via GetClipboardData (User32)
//  4) Keyboard Hooking deception via GetAsyncKeyState (User32)
// ============================

#include "pch.h"
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <easyhook.h>
#include <iostream>
#include <string>
#include <random>
#include <set>
#include <thread>

// ----- Build glue (non-logic): select proper EasyHook lib -----
#ifdef _WIN64
#pragma comment(lib, "EasyHook64.lib")
#else
#pragma comment(lib, "EasyHook32.lib") // or EasyHook64.lib as appropriate
#endif

using namespace std;

// ============================================================================
// [1] DLL Code of Screen Logging: (original content preserved)
// ============================================================================

// Pointer type for original BitBlt
typedef BOOL(WINAPI* BitBlt_t)(
	HDC hdcDest,
	int nXDest,
	int nYDest,
	int nWidth,
	int nHeight,
	HDC hdcSrc,
	int nXSrc,
	int nYSrc,
	DWORD dwRop
	);

BitBlt_t True_BitBlt = BitBlt; // fallback (will be overwritten by LhGetHookBypassAddress)

HOOK_TRACE_INFO hBitBltHook = { NULL };

// Helper: Fill the HDC region with a decoy (solid color or random noise)
void DrawDecoy(HDC hdc, int width, int height)
{
	// Simple: fill with solid red, or generate noise
	HBRUSH hBrush = CreateSolidBrush(RGB(255, 0, 0)); // Red
	RECT r = { 0, 0, width, height };
	FillRect(hdc, &r, hBrush);
	DeleteObject(hBrush);
	// (Optional) You can implement a more advanced decoy here (noise, watermark, fake UI, etc.)
}

// Our hooked BitBlt function
BOOL WINAPI myBitBltHook(
	HDC hdcDest,
	int nXDest,
	int nYDest,
	int nWidth,
	int nHeight,
	HDC hdcSrc,
	int nXSrc,
	int nYSrc,
	DWORD dwRop)
{
	// Detect virtual screen capture pattern
	int vx = GetSystemMetrics(SM_XVIRTUALSCREEN);
	int vy = GetSystemMetrics(SM_YVIRTUALSCREEN);
	int vw = GetSystemMetrics(SM_CXVIRTUALSCREEN);
	int vh = GetSystemMetrics(SM_CYVIRTUALSCREEN);

	// If full desktop capture, mislead
	if (nXDest == 0 && nYDest == 0 &&
		nXSrc == vx && nYSrc == vy &&
		nWidth == vw && nHeight == vh &&
		(dwRop & SRCCOPY)) // you can further restrict by checking dwRop
	{
		// Optionally: log the event
		cout << "[Deception] BitBlt screen capture intercepted! Returning decoy image." << endl;
		DrawDecoy(hdcDest, nWidth, nHeight);
		return TRUE; // Pretend capture was successful
	}
	// Otherwise, call the real BitBlt for legitimate usage
	return True_BitBlt(hdcDest, nXDest, nYDest, nWidth, nHeight, hdcSrc, nXSrc, nYSrc, dwRop);
}


// ============================================================================
// [2] DLL Code of Mouse Tracking: (original content preserved)
// ============================================================================

// Pointer to the original GetCursorPos
typedef BOOL(WINAPI* GetCursorPos_t)(LPPOINT lpPoint);
GetCursorPos_t TrueGetCursorPos = nullptr;

// (Make hook handle global so we can ACL after install)
HOOK_TRACE_INFO hGetCursorPosHook = { NULL };

// Custom hook for GetCursorPos
BOOL WINAPI myGetCursorPosHook(LPPOINT lpPoint)
{
	// Get the current thread ID
	DWORD currThreadId = GetCurrentThreadId();
	DWORD mainThreadId = GetCurrentProcessId(); // For demonstration

	// Here you could add more robust logic for detecting "malicious" requests
	// Example: block if called from a specific thread, or after repeated accesses, etc.
	// For PoC, let's block ALL calls and print a block message

	std::cout << "[Active Defense] Blocked mouse tracking attempt via GetCursorPos!" << std::endl;

	// Optionally: Provide fake/decoy mouse data to mislead the malware
	if (lpPoint)
	{
		lpPoint->x = 0; // Decoy/fixed position
		lpPoint->y = 0;
	}
	SetLastError(ERROR_ACCESS_DENIED);
	return FALSE; // Indicate failure
	// To allow: return TrueGetCursorPos(lpPoint);
}


// ============================================================================
// [3] DLL Code of Clipboard Logger: (original content preserved)
// ============================================================================

// Function pointer type for GetClipboardData
typedef HANDLE(WINAPI* GetClipboardData_t)(UINT uFormat);

// Global to store the real GetClipboardData
GetClipboardData_t TrueGetClipboardData = nullptr;

// (Make hook handle global so we can ACL after install)
HOOK_TRACE_INFO hClipboardHook = { NULL };

// Decoy content
const wchar_t* DECOY_TEXT = L"FAKE_PASSWORD_123!";

// Hooked GetClipboardData function
HANDLE WINAPI MyGetClipboardDataHook(UINT uFormat)
{
	// We only want to deceive for Unicode text
	if (uFormat == CF_UNICODETEXT) {
		wcout << L"[Deception] Returning decoy clipboard data!" << endl;

		size_t sizeInBytes = (wcslen(DECOY_TEXT) + 1) * sizeof(wchar_t);
		HGLOBAL hMem = GlobalAlloc(GMEM_MOVEABLE, sizeInBytes);
		if (hMem) {
			LPVOID p = GlobalLock(hMem);
			if (p) {
				memcpy(p, DECOY_TEXT, sizeInBytes);
				GlobalUnlock(hMem);
			}
			// Return our decoy clipboard handle
			return hMem;
		}
		return nullptr;
	}

	// Otherwise, call the original function for all other formats
	return TrueGetClipboardData(uFormat);
}


// ============================================================================
// [4] DLL Code of Keyboard Hooking: (original content preserved)
// ============================================================================

// Pointer to the original function
typedef SHORT(WINAPI* GetAsyncKeyState_t)(int);
GetAsyncKeyState_t Real_GetAsyncKeyState = nullptr;

// (Make hook handle global so we can ACL after install)
HOOK_TRACE_INFO hAsyncKeyHook = { NULL };

// Decoy key pool (A-Z and 0-9, could be extended)
const int decoyKeys[] = {
	'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
	'0','1','2','3','4','5','6','7','8','9'
};
constexpr int numDecoys = sizeof(decoyKeys) / sizeof(decoyKeys[0]);

// Random engine, thread-safe initialization
thread_local std::random_device rd;
thread_local std::mt19937 gen(rd());
thread_local std::uniform_int_distribution<> dis(0, numDecoys - 1);

// Track the current decoy key being "pressed" so malware sees a "new" key each time
thread_local int currentDecoyVK = 0;
thread_local bool decoyActive = false;

// Our hook: report only the decoy key as pressed, and all others as not pressed
SHORT WINAPI myGetAsyncKeyStateHook(int vKey)
{
	// Poll all keys and see if any key is truly pressed
	bool anyRealKeyPressed = false;
	for (int code = 0x08; code <= 0xFE; ++code) {
		if (code == vKey) continue; // Skip self, avoid recursion storm
		SHORT realState = Real_GetAsyncKeyState(code);
		if (realState & 0x8000) {
			anyRealKeyPressed = true;
			break;
		}
	}

	// On first detection of a real keypress, pick a random decoy VK and activate
	if (anyRealKeyPressed && !decoyActive) {
		currentDecoyVK = decoyKeys[dis(gen)];
		decoyActive = true;
	}
	// If no real key is pressed, clear decoy state
	if (!anyRealKeyPressed) {
		decoyActive = false;
		currentDecoyVK = 0;
	}

	// If the malware queries for the current decoy key, report pressed
	if (decoyActive && vKey == currentDecoyVK)
		return 0x8000;

	// All other keys are reported as not pressed
	return 0x0000;
}


// ============================================================================
// Unified EasyHook DLL entry â€” installs ALL four hooks (logic of each hook unchanged)
// ============================================================================

extern "C" void __declspec(dllexport) __stdcall NativeInjectionEntryPoint(REMOTE_ENTRY_INFO * inRemoteInfo)
{
	// ----- Screen Logging: install BitBlt hook -----
	cout << "[*] AntiScreenLoggerHook injected." << endl;

	// Install BitBlt hook
	// Corrected: use ANSI string literal
	HMODULE hGdi32 = GetModuleHandleA("gdi32.dll");
	FARPROC bitbltAddr = GetProcAddress(hGdi32, "BitBlt");
	if (!bitbltAddr) {
		cerr << "[-] Failed to get BitBlt address!" << endl;
	}
	else {
		// Save trampoline for original BitBlt
		True_BitBlt = (BitBlt_t)bitbltAddr;

		NTSTATUS res = LhInstallHook(
			bitbltAddr,
			myBitBltHook,
			nullptr,
			&hBitBltHook);

		if (FAILED(res)) {
			wstring s(RtlGetLastErrorString());
			wcerr << L"[-] Failed to install BitBlt hook: " << s << endl;
		}
		else {
			cout << "[+] BitBlt hook installed!" << endl;
			// Enable the hook for all threads (or restrict if desired)
			ULONG ACLEntries[1] = { 0 };
			LhSetExclusiveACL(ACLEntries, 1, &hBitBltHook);
		}
	}

	// ----- Mouse Tracking: install GetCursorPos hook -----
	std::cout << "[*] Injection started (AntiMouseLoggerHook)." << std::endl;

	// Get the address of GetCursorPos from user32.dll
	HMODULE hUser32_mouse = GetModuleHandleA("user32");
	if (!hUser32_mouse)
	{
		std::cerr << "[!] Failed to get handle for user32.dll" << std::endl;
	}
	else
	{
		FARPROC getCursorPosAddr = GetProcAddress(hUser32_mouse, "GetCursorPos");
		if (!getCursorPosAddr)
		{
			std::cerr << "[!] Failed to get address of GetCursorPos" << std::endl;
		}
		else
		{
			TrueGetCursorPos = (GetCursorPos_t)getCursorPosAddr;

			// Install the hook
			NTSTATUS result = LhInstallHook(
				getCursorPosAddr,
				myGetCursorPosHook,
				nullptr,
				&hGetCursorPosHook
			);

			if (FAILED(result))
			{
				std::wstring err(RtlGetLastErrorString());
				std::wcerr << L"[!] Failed to install GetCursorPos hook: " << err << std::endl;
			}
			else
			{
				std::cout << "[+] GetCursorPos hook installed successfully!" << std::endl;
				// Enable for all threads in the process (exclusive ACL, only for this process)
				ULONG ACLEntries[1] = { 0 };
				LhSetExclusiveACL(ACLEntries, 1, &hGetCursorPosHook);
			}
		}
	}

	// ----- Clipboard Logger: install GetClipboardData hook -----
	HOOK_TRACE_INFO hHook_unused_showing_original_scope_comment_only = { NULL }; // (kept to reflect original section scope)

	// Get address of GetClipboardData
	HMODULE hUser32_clip = GetModuleHandleW(L"user32.dll");
	if (!hUser32_clip) {
		wcout << L"[!] user32.dll not loaded!" << endl;
	}
	else
	{
		FARPROC pGetClipboardData = GetProcAddress(hUser32_clip, "GetClipboardData");
		if (!pGetClipboardData) {
			wcout << L"[!] GetClipboardData not found!" << endl;
		}
		else
		{
			TrueGetClipboardData = (GetClipboardData_t)pGetClipboardData;

			// Install hook
			NTSTATUS result = LhInstallHook(
				pGetClipboardData,
				MyGetClipboardDataHook,
				nullptr,
				&hClipboardHook
			);

			if (FAILED(result)) {
				wcout << L"[!] Hook install failed: " << RtlGetLastErrorString() << endl;
			}
			else
			{
				ULONG ACLEntries[1] = { 0 };
				// Apply exclusive ACL to hook everything in the process
				LhSetExclusiveACL(ACLEntries, 1, &hClipboardHook);

				wcout << L"[+] GetClipboardData hook installed successfully!" << endl;
			}
		}
	}

	// ----- Keyboard Hooking: install GetAsyncKeyState hook -----
	std::cout << "[*] Injection started. Installing GetAsyncKeyState deception hook...\n";

	HMODULE hUser32_kbd = GetModuleHandleA("user32.dll");
	if (!hUser32_kbd) {
		std::cout << "[!] Failed to get handle for user32.dll" << std::endl;
	}
	else
	{
		FARPROC asyncKeyAddr = GetProcAddress(hUser32_kbd, "GetAsyncKeyState");
		if (!asyncKeyAddr) {
			std::cout << "[!] Failed to get proc address for GetAsyncKeyState" << std::endl;
		}
		else
		{
			Real_GetAsyncKeyState = (GetAsyncKeyState_t)asyncKeyAddr;

			NTSTATUS result = LhInstallHook(asyncKeyAddr, myGetAsyncKeyStateHook, nullptr, &hAsyncKeyHook);
			if (FAILED(result)) {
				wstring s(RtlGetLastErrorString());
				wcout << L"[-] Failed to install GetAsyncKeyState hook: " << s << endl;
			}
			else
			{
				std::cout << "[+] GetAsyncKeyState hook installed successfully!\n";

				// Activate the hook for all threads in this process (the malware)
				ULONG ACLEntries[1] = { 0 };
				LhSetExclusiveACL(ACLEntries, 1, &hAsyncKeyHook);
			}
		}
	}

	// (Mouse original had an infinite Sleep loop in DllMain/entry; omitted here so all hooks can be installed within a single entry point.
	// EasyHook keeps hooks active after return; this does not change any hook logic.)
}
