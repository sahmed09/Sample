// ================================================================
// Combined Info-Stealer Deception DLL
// Techniques included (logic unchanged, original comments kept):
//   [A] File System Scanning deception via FindFirstFileA / FindNextFileA
//   [B] Registry Mining deception via RegOpenKeyExW / RegQueryValueExW
// ---------------------------------------------------------------
// Notes:
// - Coding logic is unchanged from your originals.
// - Only adjustments are structural: single translation unit,
//   unified NativeInjectionEntryPoint installing both sets of hooks,
//   shared includes/pragma, and missing standard headers.
// ================================================================

#include "pch.h"
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <winreg.h>
#include <easyhook.h>
#include <iostream>
#include <string>
#include <vector>
#include <random>
#include <map>
#include <algorithm>  // (Needed for std::transform)
#include <cstring>    // (Needed for strcpy_s)

// ---- Link to EasyHook (auto-select 32/64). This is build glue, not logic. ----
#ifdef _WIN64
#pragma comment(lib, "EasyHook64.lib")
#else
#pragma comment(lib, "EasyHook32.lib")
#endif

using namespace std;


// ============================================================================
// [A] DLL Code of File System Scanning (ORIGINAL CONTENT PRESERVED)
// ============================================================================

// Sensitive keywords/extension targets
const std::vector<std::string> kSensitiveExt = { ".json", ".conf", ".ini", ".txt", ".dat" };
const std::vector<std::string> kSensitiveSubstr = { "api_key", "wallet", "credential", "password", "secret", "config", "browser", "profile" };

// Decoy filenames to mislead malware
const std::vector<std::string> kDecoyFiles = {
	"not_a_password.txt",
	"wallet_backup.conf",
	"api_key_dummy.json",
	"secret_placeholder.dat",
	"browser_profile_fake.ini",
	"credentials_test.txt"
};

// Original function pointers
typedef HANDLE(WINAPI* PFN_FindFirstFileA)(LPCSTR, LPWIN32_FIND_DATAA);
typedef BOOL(WINAPI* PFN_FindNextFileA) (HANDLE, LPWIN32_FIND_DATAA);

PFN_FindFirstFileA TrueFindFirstFileA = FindFirstFileA;
PFN_FindNextFileA  TrueFindNextFileA = FindNextFileA;

// Internal state to serve decoy files
struct FakeFindHandle {
	size_t idx;
	std::vector<std::string> files;
};
std::map<HANDLE, FakeFindHandle> g_fakeHandles;

// Utility: checks if a filename looks "sensitive"
bool IsSensitive(const std::string& fname) {
	std::string lower = fname;
	std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
	for (const auto& ext : kSensitiveExt)
		if (lower.size() >= ext.size() && lower.compare(lower.size() - ext.size(), ext.size(), ext) == 0)
			return true;
	for (const auto& kw : kSensitiveSubstr)
		if (lower.find(kw) != std::string::npos)
			return true;
	return false;
}

// Hooked FindFirstFileA
HANDLE WINAPI myFindFirstFileAHook(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)
{
	std::string mask = lpFileName ? lpFileName : "";
	bool looksMaliciousScan = false;

	// Very simple heuristic: malware scans directories with mask "*"
	if (mask.find("*") != std::string::npos) {
		looksMaliciousScan = true;
	}
	// Could check for known malware scan paths/filenames here.

	if (looksMaliciousScan) {
		// Serve decoy files
		static int handleSeed = 12345;
		HANDLE fakeHandle = (HANDLE)(++handleSeed);
		g_fakeHandles[fakeHandle] = { 0, kDecoyFiles };

		// Return first decoy
		strcpy_s(lpFindFileData->cFileName, MAX_PATH, kDecoyFiles[0].c_str());
		lpFindFileData->dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
		return fakeHandle;
	}

	// Legitimate - call real API
	return TrueFindFirstFileA(lpFileName, lpFindFileData);
}

// Hooked FindNextFileA
BOOL WINAPI myFindNextFileAHook(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData)
{
	auto it = g_fakeHandles.find(hFindFile);
	if (it != g_fakeHandles.end()) {
		// Serve next decoy, if any
		it->second.idx++;
		if (it->second.idx < it->second.files.size()) {
			strcpy_s(lpFindFileData->cFileName, MAX_PATH, it->second.files[it->second.idx].c_str());
			lpFindFileData->dwFileAttributes = FILE_ATTRIBUTE_NORMAL;
			return TRUE;
		}
		else {
			g_fakeHandles.erase(it);
			SetLastError(ERROR_NO_MORE_FILES);
			return FALSE;
		}
	}

	// Legitimate - call real API
	return TrueFindNextFileA(hFindFile, lpFindFileData);
}


// ============================================================================
// [B] DLL Code of Registry Mining (ORIGINAL CONTENT PRESERVED)
// ============================================================================

// Global variables to identify fake key handles
static HKEY g_FakeWinlogonKey = (HKEY)0xDEADBEEF; // Arbitrary value, unlikely to clash

// Function pointers for original APIs
typedef LONG(WINAPI* RegOpenKeyExW_t)(HKEY, LPCWSTR, DWORD, REGSAM, PHKEY);
typedef LONG(WINAPI* RegQueryValueExW_t)(HKEY, LPCWSTR, LPDWORD, LPDWORD, LPBYTE, LPDWORD);

RegOpenKeyExW_t TrueRegOpenKeyExW = nullptr;
RegQueryValueExW_t TrueRegQueryValueExW = nullptr;

// Intercepted RegOpenKeyExW
LONG WINAPI myRegOpenKeyExWHook(
	HKEY hKey,
	LPCWSTR lpSubKey,
	DWORD ulOptions,
	REGSAM samDesired,
	PHKEY phkResult
) {
	if (
		hKey == HKEY_LOCAL_MACHINE &&
		lpSubKey &&
		_wcsicmp(lpSubKey, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon") == 0
		) {
		// Return fake handle for the Winlogon key
		*phkResult = g_FakeWinlogonKey;
		std::wcout << L"[Deception] RegOpenKeyExW intercepted Winlogon, returning fake handle." << std::endl;
		return ERROR_SUCCESS;
	}
	// Otherwise, call the real function
	return TrueRegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);
}

// Intercepted RegQueryValueExW
LONG WINAPI myRegQueryValueExWHook(
	HKEY hKey,
	LPCWSTR lpValueName,
	LPDWORD lpReserved,
	LPDWORD lpType,
	LPBYTE lpData,
	LPDWORD lpcbData
) {
	// Intercept only for our fake handle and protected value names
	if (hKey == g_FakeWinlogonKey && lpValueName) {
		std::wstring val(lpValueName);
		if (
			val == L"DefaultPassword" ||
			val == L"DefaultUserName" ||
			val == L"DefaultDomainName" ||
			val == L"AutoAdminLogon" ||
			val == L"AltDefaultUserName" ||
			val == L"AltDefaultDomainName"
			) {
			std::wstring fakeValue = L"Fake1234!!!!"; // You can vary this value for more deception
			DWORD fakeType = REG_SZ;
			DWORD bytesNeeded = (DWORD)((fakeValue.length() + 1) * sizeof(wchar_t));
			if (lpData && lpcbData && *lpcbData >= bytesNeeded) {
				memcpy(lpData, fakeValue.c_str(), bytesNeeded);
				*lpType = fakeType;
				*lpcbData = bytesNeeded;
				std::wcout << L"[Deception] RegQueryValueExW intercepted " << val << L", returning fake data." << std::endl;
				return ERROR_SUCCESS;
			}
			else if (lpcbData) {
				*lpcbData = bytesNeeded;
				if (lpType)*lpType = fakeType;
				return ERROR_MORE_DATA;
			}
		}
	}
	// Otherwise, call the real function
	return TrueRegQueryValueExW(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
}


// ============================================================================
// Unified EasyHook DLL entry point â€” installs BOTH [A] and [B] hooks
// (Hook logic remains exactly as in originals.)
// ============================================================================

extern "C" void __declspec(dllexport) __stdcall NativeInjectionEntryPoint(REMOTE_ENTRY_INFO * inRemoteInfo)
{
	// ---------------------------
	// [A] Install File System Scanning hooks
	// ---------------------------
	std::cout << "[*] AntiFileScannerHook DLL injected!" << std::endl;

	HOOK_TRACE_INFO hFindFirstFileA = { NULL };
	HOOK_TRACE_INFO hFindNextFileA = { NULL };

	// Install the hooks
	FARPROC fFirst = GetProcAddress(GetModuleHandleA("kernel32.dll"), "FindFirstFileA");
	FARPROC fNext = GetProcAddress(GetModuleHandleA("kernel32.dll"), "FindNextFileA");
	if (fFirst) LhInstallHook(fFirst, myFindFirstFileAHook, nullptr, &hFindFirstFileA);
	if (fNext)  LhInstallHook(fNext, myFindNextFileAHook, nullptr, &hFindNextFileA);

	// Exclusive ACL: only affect hooked process (the malware)
	ULONG ACLEntriesFS[1] = { 0 };
	LhSetExclusiveACL(ACLEntriesFS, 1, &hFindFirstFileA);
	LhSetExclusiveACL(ACLEntriesFS, 1, &hFindNextFileA);

	std::cout << "[*] File system API hooks installed." << std::endl;

	// ---------------------------
	// [B] Install Registry Mining hooks
	// ---------------------------
	std::cout << "[*] Injection started for Registry Mining Deception." << std::endl;

	// Resolve original API addresses
	TrueRegOpenKeyExW = (RegOpenKeyExW_t)GetProcAddress(GetModuleHandleW(L"advapi32"), "RegOpenKeyExW");
	TrueRegQueryValueExW = (RegQueryValueExW_t)GetProcAddress(GetModuleHandleW(L"advapi32"), "RegQueryValueExW");

	HOOK_TRACE_INFO hRegOpenKeyExHook = { NULL };
	HOOK_TRACE_INFO hRegQueryValueExHook = { NULL };

	// Install hooks
	if (TrueRegOpenKeyExW)
		LhInstallHook((LPVOID)TrueRegOpenKeyExW, myRegOpenKeyExWHook, nullptr, &hRegOpenKeyExHook);
	if (TrueRegQueryValueExW)
		LhInstallHook((LPVOID)TrueRegQueryValueExW, myRegQueryValueExWHook, nullptr, &hRegQueryValueExHook);

	// Enable for all threads in current process
	ULONG ACLEntriesReg[1] = { 0 };
	LhSetExclusiveACL(ACLEntriesReg, 1, &hRegOpenKeyExHook);
	LhSetExclusiveACL(ACLEntriesReg, 1, &hRegQueryValueExHook);

	std::cout << "[*] Registry API hooks installed.\n";
}
